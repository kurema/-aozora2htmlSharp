<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TagSyntaxError" xml:space="preserve">
    <value>注記を重ねる際の原則、「狭い範囲を先に、広い範囲を後に」が守られていません。リンク先の指針を参考に、書き方をあらためてください</value>
  </data>
  <data name="UndefinedHeader" xml:space="preserve">
    <value>未定義な見出しです</value>
  </data>
  <data name="UseCrlf" xml:space="preserve">
    <value>改行コードを、「CR+LF」にあらためてください</value>
  </data>
  <data name="ErrorStop" xml:space="preserve">
    <value>エラー({0}行目):{1}. &#13;&#10;処理を停止します</value>
  </data>
  <data name="InvalidFontSize" xml:space="preserve">
    <value>文字サイズの指定が不正です</value>
  </data>
  <data name="UnsupportedRuby" xml:space="preserve">
    <value>サポートされていない複雑なルビ付けです</value>
  </data>
  <data name="WarnOnebyte" xml:space="preserve">
    <value>警告({0}行目):1バイトの「{1}」が使われています</value>
  </data>
  <data name="WarnChuki" xml:space="preserve">
    <value>警告({0}行目):注記記号の誤用の可能性がある、「{1}」が使われています</value>
  </data>
  <data name="WarnJisGaiji" xml:space="preserve">
    <value>警告({0}行目):JIS外字「{1}」が使われています</value>
  </data>
  <data name="DontCrlfInStyle" xml:space="preserve">
    <value>{0}中に改行されました。改行をまたぐ要素にはブロック表記を用いてください</value>
  </data>
  <data name="TerminateInStyle" xml:space="preserve">
    <value>{0}中に本文が終了しました</value>
  </data>
  <data name="InvalidClosing" xml:space="preserve">
    <value>{0}を閉じようとしましたが、{0}中ではありません</value>
  </data>
  <data name="InvalidNesting" xml:space="preserve">
    <value>{0}を終了しようとしましたが、{1}中です</value>
  </data>
  <data name="DontUseDoubleRuby" xml:space="preserve">
    <value>同じ箇所に2つのルビはつけられません</value>
  </data>
  <data name="DontAllowTripleRuby" xml:space="preserve">
    <value>1つの単語に3つのルビはつけられません</value>
  </data>
  <data name="WarnUnexpectedTerminator" xml:space="preserve">
    <value>警告({0}行目):予期せぬファイル終端</value>
  </data>
  <data name="WarnUndefinedCommand" xml:space="preserve">
    <value>警告({0}行目):「{1}」は未対応のコマンドのため無視します</value>
  </data>
  <data name="WarnInvalidAccentBrancket" xml:space="preserve">
    <value>警告({0}行目):アクセント分解の亀甲括弧の始めと終わりが、行中で揃っていません</value>
  </data>
</root>